<?php
namespace php_active_record;
/* This can be a template to update a resource's taxon.tab file by adding a canonicalName generated by gnparser.

First client: Brazilian_Flora.tar.gz
php update_resources/connectors/run_gnparser_dwca.php _ '{"resource_id": "Brazilian_Flora"}'

2nd client: for neo4j trait resources
php update_resources/connectors/run_gnparser_dwca.php _ '{"resource_id": "globi_assoc"}'
php update_resources/connectors/run_gnparser_dwca.php _ '{"resource_id": "WoRMS2EoL"}'


Initialy this library only does the API lookup service.
Now the command line gnparser option is the default. No more lookup, very slow and too many API calls.

As of this writing: Global Names Parser (v1.7.1) - https://parser.globalnames.org/doc/api

These ff. workspaces work together:
- DHConnLib_8.code-workspace
- GNParserAPI_8.code-workspace
- DwCA_MatchTaxa2DH.code-workspace
- generate_higherClassification_8.code-workspace
====================================================================
$ nohup php run_gnparser_dwca.php _ "{'resource_id': 'Brazilian_Flora'}" > terminal_BF_canonical.out 2>&1 &
-> use 'nohup' so it continues even after logging out of the terminal
For diagnostics:
    ps --help simple
    ps -r 
        -> very helpful, if u want to check current running processes
    
    cd /var/www/html/eol_php_code/
    tail terminal_BF_canonical.out
    cat terminal_BF_canonical.out
        -> to see progress, very convenient
    ps -p xxx
        -> to investigate a running PID
    kill -9 xxx
        -> to kill a running PID
====================================================================
*/

include_once(dirname(__FILE__) . "/../../config/environment.php");
// /* during development
ini_set('error_reporting', E_ALL);
ini_set('display_errors', true);
$GLOBALS['ENV_DEBUG'] = true; //set to true during development
// */
// ini_set('memory_limit','7096M');
$timestart = time_elapsed();

// print_r($argv);
$params['jenkins_or_cron'] = @$argv[1]; //not needed here
$param                     = json_decode(@$argv[2], true); // print_r($param); exit;
$resource_id = $param['resource_id'];

$dwca_file = 'https://editors.eol.org/eol_php_code/applications/content_server/resources/' . $resource_id . '.tar.gz';
$dwca_file = WEB_ROOT . "/applications/content_server/resources_3/" . $resource_id . ".tar.gz"; //during dev only

// /* Customize during dev:
if ($resource_id == "WoRMS2EoL") {
    $dwca_file = LOCAL_HOST . "/cp/WORMS/WoRMS2EoL.zip";
}
// */

/* old implementation
if($resource_id == "Brazilian_Flora") $resource_id = "Brazilian_Flora_with_canonical";
else exit("\nresource_id [$resource_id] not yet initialized. \n");
*/
$resource_id .= "_neo4j_1"; //latest implementation

process_resource_url($dwca_file, $resource_id, $timestart);

function process_resource_url($dwca_file, $resource_id, $timestart)
{
    require_library('connectors/DwCA_Utility');
    $params['resource'] = "add_canonical_Katja";
    $func = new DwCA_Utility($resource_id, $dwca_file, $params);

    $preferred_rowtypes = array("http://rs.gbif.org/terms/1.0/vernacularname", "http://eol.org/schema/reference/reference", 
        "http://rs.tdwg.org/dwc/terms/occurrence", "http://rs.tdwg.org/dwc/terms/measurementorfact", "http://eol.org/schema/association",    
        "http://eol.org/schema/agent/agent", "http://eol.org/schema/media/document");
    $preferred_rowtypes[] = "http://rs.gbif.org/terms/1.0/reference"; //just in case used by some DwCA
    $excluded_rowtypes = array('http://rs.tdwg.org/dwc/terms/taxon');

    /* This will be processed in DwCA_RunGNParser.php.php which will be called from DwCA_Utility.php */
    $func->convert_archive($preferred_rowtypes, $excluded_rowtypes);
    Functions::finalize_dwca_resource($resource_id, false, true, $timestart);
}

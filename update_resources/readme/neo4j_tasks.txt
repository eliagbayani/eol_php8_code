

export NEO4J_HOME=/Volumes/Crucial_4TB/other_files/neo4j-enterprise-2025.05.0
export NEO4J_CONF=/Volumes/Crucial_4TB/other_files/neo4j_custom_files/conf

To remove environment variable:
unset NEO4J_CONF

$NEO4J_HOME/bin/neo4j-admin server license --accept-evaluation

RUN in command line:
bin/neo4j-admin dbms set-initial-password neo4j_eli
-> Changed password for user 'neo4j'

==========================================

- get all relationships of a node, in this case an actor
MATCH (e:Person {name: "Tom Hanks"})-[]->(n)
RETURN e, n

- delete Tom Hanks and its relationships
MATCH (e:Person {name: "Tom Hanks"})
DETACH DELETE e


- good practice for creating nodes:
MERGE (m:Movie {title: "World War Z"})
ON CREATE SET m.createdAt = datetime()
ON MATCH SET m.updatedAt = datetime()
SET p.gross_income = 1000000

- good practice is to separate the creation of nodes from the creation of its relationships
e.g.
MERGE (p:Person {name: "Brad Pitt"})
MERGE (p:Movie {title: "Zulu Dawn"})
MERGE (p)-[:ACTED_IN]->(m)
RETURN p,m

- how to delete a property (e.g. roles) from a relationship:
MATCH (p:Person)-[r:ACTED_IN]->(m:Movie)
WHERE p.name = "Tom Hanks" AND m.title = "Apollo 13"
REMOVE r.roles.         {option 1}
OR
SET r.roles = null      {option 2}

- how to delete a relationship from the graph: using example above:
DELETE r                {delete the reference to the relationship, this case 'r'}

e.g. another example to delete a relationship
MATCH (p:Person {name:"Jane Doe"})-[r:ACTED_IN]->(m:Movie {title: "The Matrix"})
DELETE r
RETURN p,m           {RETURN row is optional}


- how to delete a node from the graph. You can do below if the node doesn't have relationships
MATCH (p:Person)
WHERE p.name = "Jane Doe"
DELETE p

- you cannot delete a node if it has a relationship with another node

- use DETACH DELETE if u want to delete a node that has a relationship(s)
DETACH DELETE deletes first all relationships of the node then deletes the node

WARNING: this code will delete all nodes and relationships in your graph
MATCH (n)
DETACH DELETE n
-> will truncate your entire database

=======================================================================

MATCH (sandy:User {name: 'Sandy Jones'})
MATCH (clinton:User {name: 'Clinton Spencer'})
MATCH (apollo:Movie {title: 'Apollo 13'})
MATCH (sleep:Movie {title: 'Sleepless in Seattle'})
MATCH (hoffa:Movie {title: 'Hoffa'})
MERGE (sandy)-[:RATED {rating:5}]->(apollo)
MERGE (sandy)-[:RATED {rating:4}]->(sleep)
MERGE (clinton)-[:RATED {rating:3}]->(apollo)
MERGE (clinton)-[:RATED {rating:3}]->(sleep)
MERGE (clinton)-[:RATED {rating:3}]->(hoffa)

Use MATCH to find the User and Movie nodes, 
then use MERGE to create the relationships between the two nodes.

Remember that you must specify or infer(left-to-right) a direction when you create a relationship.

You should create a total of 5 RATED relationships in the graph, each with a property, rating.
=======================================

Use case #1: What people acted in a movie?
MATCH (p:Person)-[:ACTED_IN]-(m:Movie)
WHERE m.title = 'Sleepless in Seattle'
RETURN p.name AS Actor

Use case #2: What person directed a movie?
MATCH (p:Person)-[:DIRECTED]-(m:Movie)
WHERE m.title = 'Hoffa'
RETURN  p.name AS Director

Use case #3: What movies did a person act in?
MATCH (p:Person)-[:ACTED_IN]-(m:Movie)
WHERE p.name = 'Tom Hanks'
RETURN m.title AS Movie

Use case #4: How many users rated a movie?
sol'n:
MATCH (u:User)-[:RATED]-(m:Movie)
WHERE m.title = 'Apollo 13'
RETURN count(*) AS `Number of reviewers`

Use case #5: Who was the youngest person to act in a movie?
MATCH (p:Person)-[:ACTED_IN]-(m:Movie)
WHERE m.title = 'Hoffa'
RETURN  p.name AS Actor, p.born as `Year Born` ORDER BY p.born DESC LIMIT 1

Use case #6: What role did a person play in a movie?
MATCH (p:Person)-[r:ACTED_IN]-(m:Movie)
WHERE m.title = 'Sleepless in Seattle' AND
p.name = 'Meg Ryan'
RETURN  r.role AS Role

Use case #7: What is the highest rated movie in a particular year according to imDB?
MATCH (m:Movie)
WHERE m.released STARTS WITH '1995'
RETURN  m.title as Movie, m.imdbRating as Rating ORDER BY m.imdbRating DESC LIMIT 1

Use case #8: What drama movies did an actor act in?
MATCH (p:Person)-[:ACTED_IN]-(m:Movie)
WHERE p.name = 'Tom Hanks' AND
'Drama' IN m.genres
RETURN m.title AS Movie

Use case #9: What users gave a movie a rating of 5?
MATCH (u:User)-[r:RATED]-(m:Movie)
WHERE m.title = 'Apollo 13' AND
r.rating = 5
RETURN u.name as Reviewer

Use case #10: What actors were born before 1950?
MATCH (p:Person)
WHERE p.born < '1950'
RETURN p.name

========================================
MATCH (n) RETURN n
-> returns all nodes in the graph.

MATCH (n:Person) RETURN n
-> Returns all Person nodes in the graph.

========================================== Do not overuse labels
- Only use them if they will help most of your use cases.
- Best practice: Limit the maximum number of labels per node to 4.

Tutorial for making new labels, why and why not:
https://graphacademy.neo4j.com/courses/modeling-fundamentals/5-refactoring-graph/2-labels-in-graph/

What actors where born before 1950?
MATCH (p:Person)-[:ACTED_IN]-()
WHERE p.born < '1950'
RETURN p.name

below use PROFILE to see performance hits:

PROFILE
MATCH (p:Person)-[:ACTED_IN]-()
WHERE p.born < '1950'
RETURN p.name

the query above will be too slow if you have millions under the label Person.
Some of which are not actors.
to refactor and add a new label Actor:
MATCH (p:Person)
WHERE exists( (p)-[ACTED_IN]-() )
SET p:Actor
-> select all person nodes with an ACTED_IN relationship then we set a label for the node
in this case a label Actor.

----------- after adding the Actor label: Rewritten use cases below: 
basically replace the Person label to Actor label

Use case #1: What people acted in a movie?
MATCH (p:Actor)-[:ACTED_IN]-(m:Movie)
WHERE m.title = 'Sleepless in Seattle'
RETURN p.name AS Actor

Use case #3: What movies did a person act in?
MATCH (p:Actor)-[:ACTED_IN]-(m:Movie)
WHERE p.name = 'Tom Hanks'
RETURN m.title AS Movie

Use case #5: Who was the youngest person to act in a movie?
MATCH (p:Actor)-[:ACTED_IN]-(m:Movie)
WHERE m.title = 'Hoffa'
RETURN  p.name AS Actor, p.born as `Year Born` ORDER BY p.born DESC LIMIT 1

Use case #6: What role did a person play in a movie?
MATCH (p:Actor)-[r:ACTED_IN]-(m:Movie)
WHERE m.title = 'Sleepless in Seattle' AND
p.name = 'Meg Ryan'
RETURN  r.role AS Role

Use case #8: What drama movies did an actor act in?
MATCH (p:Actor)-[:ACTED_IN]-(m:Movie)
WHERE p.name = 'Tom Hanks' AND
'Drama' IN m.genres
RETURN m.title AS Movie

Use case #10: What actors were born before 1950?
MATCH (p:Actor)
WHERE p.born < '1950'
RETURN p.name
=====================================================================
Adding the Director Label
In a previous Challenge, you added the Actor label to the nodes in the graph.
Modify the query to add a DIRECTOR label the Person nodes that have the outgoing DIRECTED relationship.

MATCH (p:Person) 
WHERE exists ((p)-[:DIRECTED]->()) 
SET p:Director
-------------------------------
Use case #2: What person directed a movie?
Modify this query to use the Director label, then test this use case using the movie, Hoffa.

MATCH (p:Person)-[:DIRECTED]-(m:Movie)
WHERE m.title = 'Hoffa'
RETURN  p.name AS Director

below should now also have the same results: i.e. using the new Director label instead of Person.

MATCH (p:Director)-[:DIRECTED]-(m:Movie)
WHERE m.title = 'Hoffa'
RETURN  p.name AS Director
===============================================================================
Adding Language Data
In the previous lesson, you learned that duplicating data in the graph can be expensive.
To illustrate duplication of data, you will add a languages property to each Movie node in the instance model, before refactoring to eliminate the duplication.
Execute this Cypher code to add a languages property to the Movie nodes of the graph:

MATCH (apollo:Movie {title: 'Apollo 13'})
MATCH (sleep:Movie {title: 'Sleepless in Seattle'})
MATCH (hoffa:Movie {title: 'Hoffa'})
MATCH (casino:Movie {title: 'Casino'})
SET apollo.languages = ['English']
SET sleep.languages =  ['English']
SET hoffa.languages =  ['English', 'Italian', 'Latin']
SET casino.languages =  ['English']
===============================================================================
Use case #11: What movies are available in a particular language?
With this query, we find all movies in Italian.

MATCH (m:Movie)
WHERE 'Italian' IN m.languages
RETURN m.title

What this query does is retrieve all Movie nodes and then test whether the languages property contains Italian. There are two issues with the data model, especially if the graph scales:

1. The name of the language is duplicated in many Movie nodes.
2. In order to perform the query, all Movie nodes must be retrieved.
A solution here is to model properties as nodes.

Refactor properties as nodes:

Here are the steps we use to refactor:

1. Take the property values for each Movie node and create a Language node.
2. Create the IN_LANGUAGE relationship between that Movie node and the Language node.
3. Finally, remove the languages property from the Movie node.

This is the code to refactor the graph to turn the property values into nodes:

MATCH (m:Movie)
UNWIND m.languages AS language
-> Take the property values for each Movie node and...
MERGE (l:Language {name:language})
-> create a Language node
MERGE (m)-[:IN_LANGUAGE]->(l)
-> Create the IN_LANGUAGE relationship between that Movie node and the Language node.
SET m.languages = null
-> Finally, remove the languages property from the Movie node.

This code iterates through all Movie nodes and creates a Language node for each language it finds and then creates the relationship between the Movie node and Language node using the IN_LANGUAGE relationship.
It uses the Cypher UNWIND clause to separate each element of the languages property list into a separate row value that is processed later in the query.
This is what the instance model looks like after the refactoring:
https://graphacademy.neo4j.com/courses/modeling-fundamentals/6-eliminating-duplicate-data/3-refactor-duplicate-data/
There will only be one node with the language value of English and we remove the languages property from all Movie nodes. 
This eliminates a lot of duplication in the graph.

MATCH (m:Movie)
UNWIND m.languages AS language

MERGE (l:Language {name:language})
MERGE (m)-[:IN_LANGUAGE]->(l)
SET m.languages = null

* What Cypher clause do you use to separate list elements? ANS: UNWIND

Modifying the Cypher statement
This is the Cypher code for the use case before the refactoring:
MATCH (m:Movie)
WHERE 'Italian' IN m.languages
RETURN m.title

This query can now be modified to use the newly-created Language node:
MATCH (m:Movie)-[:IN_LANGUAGE]-(l:Language)
WHERE  l.name = 'Italian'
RETURN m.title

===============================================================================
Eliminating Complex Data in Nodes
Use csae 12: What movies did an actor act in for a particular year?
MATCH (p:Actor)-[:ACTED_IN]-(m:Movie)
WHERE p.name = 'Tom Hanks' AND
m.released STARTS WITH '1995'
RETURN m.title AS Movie

Use case 13: What actors or directors worked in a particular year?
MATCH (p:Person)--(m:Movie)
WHERE m.released STARTS WITH '1995'
RETURN DISTINCT p.name as 'Actor or Director'

After refactoring our dbase (using the APOC library), we can now update our query for our use cases:
12: Rewritten
MATCH (p:Actor)-[:ACTED_IN_1995]-(m:Movie)
WHERE p.name = 'Tom Hanks' 
RETURN m.title AS Movie

13: Rewritten
MATCH (p:Person)-[:ACTED_IN_1995|DIRECTED_1995]-()
RETURN p.name as 'Actor or Director'

Solution:
The APOC library contains a number of procedures that can be called to create labels and relationship types 
based on dynamic arguments passed to the procedure.


=============================================================================== Challenge
Specializing ACTED_IN and DIRECTED Relationships
In this Challenge, you will modify the instance model to match the following diagram. 
This diagram uses specialized ACTED_IN and DIRECTED relationships.
https://graphacademy.neo4j.com/courses/modeling-fundamentals/7-using-specific-relationships/2-c-add-actedin-types/images/instance-specialize-acted-directed.png

This Challenge has 2 steps:
1. Refactor all ACTED_IN relationships
2. Refactor all DIRECTED relationships

Refactor all ACTED_IN relationships
Execute the following code to create a new set of relationships based on the year of the released property for each Node.
For example, Apollo 13 was released in 1995, so an additional ACTED_IN_1995 will be created between Apollo 13 and any actor that acted in the movie.

MATCH (n:Actor)-[:ACTED_IN]->(m:Movie)
CALL apoc.merge.relationship(n,
  'ACTED_IN_' + left(m.released,4),
  {},
  {},
  m ,
  {}
) YIELD rel
RETURN count(*) AS `Number of relationships merged`;
-> should create 5 relationships.

Rewritten: Use case #12: What movies did an actor act in for a particular year?
MATCH (p:Actor)-[:ACTED_IN_1995]->(m:Movie)
WHERE p.name = 'Tom Hanks'
RETURN m.title AS Movie
-> should return 1 movie: Apollo 13.
-----------------------------------------------
Refactor all DIRECTED relationships
We can use the same method to create DIRECTED_{year} relationships between the Director and the Movie.
Modify the code you have just ran to create the ACTED_IN_{year} relationships to create DIRECTED_{year} relationships for Director nodes.
MATCH (n:Actor)-[:DIRECTED]->(m:Movie)
CALL apoc.merge.relationship(n,
  'DIRECTED_' + left(m.released,4),
  {},
  {},
  m ,
  {}
) YIELD rel
RETURN count(*) AS `Number of relationships merged`;

=============================================================================== Challenge
Specializing RATED Relationships
Use case #9: What users gave a movie a rating of 5?

Why create specialized relationships?
Letâ€™s take a practical example. Run this Cypher code to test this use case with the movie, Apollo 13.
MATCH (u:User)-[r:RATED]->(m:Movie)
WHERE m.title = 'Apollo 13' AND
r.rating = 5
RETURN u.name as Reviewer
-> it should return the User Sandy Jones

What if there were thousands of Users in the graph. This query would need to traverse all RATED relationships and evaluate the rating property. For a large graph, more evaluations mean longer query processing time.
In this challenge, you will specialize the RATED relationships to reflect the rating. Unlike the refactoring where we removed the genres and languages properties from the nodes, we will not remove the rating property from the RATED relationship. This is because we may need it for a query that has a reference to the relationship and needs to return the rating value.
This is the instance model you will refactor toward:
https://graphacademy.neo4j.com/courses/modeling-fundamentals/7-using-specific-relationships/3-c-add-rated-types/images/instance-specialize-rated.png

Creating specialized RATED_{rating} Relationships
// Modify query above to use the -[:RATED]->()
// relationship to create a new RATED_{rating}
// relationship between the :User and a :Movie
MATCH (u:User)-[r:RATED]->(m:Movie)
CALL apoc.merge.relationship(u,
  'RATED_' + r.rating,
  {},
  {},
  m ,
  {}
) YIELD rel
RETURN count(*) AS `Number of relationships merged`

=============================================================================== new course
Importing Data Fundamentals

Lesson: Tools
In this lesson, you will explore some tools you can use to import data into Neo4j.
https://graphacademy.neo4j.com/courses/importing-fundamentals/1-importing-data/3-tools/
You will learn about:
    Data Importer -> The Neo4j Data Importer is a "no-code" tool that facilitates data importing from relational data sources into Neo4j. Its graphical user interface allows for simple data conversion into nodes and relationships.
    Cypher and LOAD CSV -> Cypher has built-in support for importing data from CSV files using the LOAD CSV clause.
    neo4j-admin -> The neo4j-admin import command line interface supports importing large data sets. neo4j-admin import converts CSV files into the internal binary format of Neo4j and can import millions of rows within minutes.
    ETL tools
    Custom application | Custom integration using Neo4j drivers


e.g. Cypher and LOAD CSV:
LOAD CSV WITH HEADERS FROM 'file:///transactions.csv' AS row
MERGE (t:Transactions {id: row.id})
SET
    t.reference = row.reference,
    t.amount = toInteger(row.amount),
    t.timestamp = datetime(row.timestamp)
===============================================================================
Data Importer
connection url - bolt+s://980409cf205eda609f56440410e83d91.neo4jsandbox.com:7687
               -          980409cf205eda609f56440410e83d91.neo4jsandbox.com:7687
user - neo4j
pw   - rifling-loudspeakers-equipment

* I got the credentials from: Neo4j Sandbox: [Connection details]
https://sandbox.neo4j.com/?_gl=1*15i6f0s*_gcl_au*MzUxOTIzMzU5LjE3NTAwODc4MDIuMTY2NjIyNzY2OS4xNzUwMTc5MzY2LjE3NTAxNzk0NDE.*_ga*MTU1NjM4MTAxOC4xNzUwMDg3ODAy*_ga_DL38Q8KGQC*czE3NTA2OTEzNTUkbzEzJGcxJHQxNzUwNjk3MTM0JGo2MCRsMCRoMA..*_ga_DZP8Z65KK4*czE3NTA2OTEzNTUkbzEzJGcxJHQxNzUwNjk3MTM0JGo2MCRsMCRoMA..

=============================================================================== for Documentation
https://arrows.app/#/local/id=yj6WmdcOcJ_Flll6vF_B

===============================================================================
Congratulations and Next Steps

Congratulations on completing "Importing Data Fundamentals"!

You have learned about the options and processes for importing data into Neo4j and how to use the Neo4j Data Importer tool.

You can continue your Neo4j Learning journey on GraphAcademy with the following courses:

- Importing CSV data into Neo4j - Learn how to import CSV data into Neo4j using Cypher.
https://graphacademy.neo4j.com/courses/importing-cypher/
- Introduction to Vector Indexes and Unstructured Data - Understand and search unstructured data using vector indexes.
https://graphacademy.neo4j.com/courses/llm-vectors-unstructured

You may also find the 
- Import your data into Neo4j section (https://neo4j.com/docs/getting-started/data-import?_gl=1*3fvgql*_gcl_au*MzUxOTIzMzU5LjE3NTAwODc4MDIuMTY2NjIyNzY2OS4xNzUwMTc5MzY2LjE3NTAxNzk0NDE.*_ga*MTU1NjM4MTAxOC4xNzUwMDg3ODAy*_ga_DL38Q8KGQC*czE3NTA3NzYwNjMkbzE0JGcxJHQxNzUwNzg0MTgzJGo2MCRsMCRoMA..*_ga_DZP8Z65KK4*czE3NTA3NzYwNjMkbzE0JGcxJHQxNzUwNzg0MTgzJGo2MCRsMCRoMA..)
of the Neo4j Getting Started Guide (https://neo4j.com/docs/getting-started/?_gl=1*3fvgql*_gcl_au*MzUxOTIzMzU5LjE3NTAwODc4MDIuMTY2NjIyNzY2OS4xNzUwMTc5MzY2LjE3NTAxNzk0NDE.*_ga*MTU1NjM4MTAxOC4xNzUwMDg3ODAy*_ga_DL38Q8KGQC*czE3NTA3NzYwNjMkbzE0JGcxJHQxNzUwNzg0MTgzJGo2MCRsMCRoMA..*_ga_DZP8Z65KK4*czE3NTA3NzYwNjMkbzE0JGcxJHQxNzUwNzg0MTgzJGo2MCRsMCRoMA..)
helpful.
===============================================================================
Next steps:
https://graphacademy.neo4j.com/certifications/neo4j-certification/

=============================================================================== New Chapter: 
Loading CSV files
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/people.csv' as row
RETURN count(row)

LOAD CSV WITH HEADERS FROM "https://drive.google.com/uc?export=download&id=1bkCg8Dy4bSWQF6Lz2wJi5xpgQeeT1JAR" AS row 
FIELDTERMINATOR "|"
RETURN row
-> works OK by Eli
===============================================================================
Create Person nodes
Run the Cypher statement to create the Person nodes:
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/persons.csv' AS row
MERGE (p:Person {tmdbId: toInteger(row.person_tmdbId)})
SET
p.imdbId = toInteger(row.person_imdbId),
p.bornIn = row.bornIn,
p.name = row.name,
p.bio = row.bio,
p.poster = row.poster,
p.url = row.url,
p.born = row.born,
p.died = row.died
---------------------------------------------------
Unique IDs and Constraints
A Neo4j best practice is to use an ID as a unique property value for each node.
Unique IDs help ensure duplicate data is not created. When you load data from CSV files, you rely heavily upon the IDs specified in the file. 
If the IDs in your CSV file are not unique for the same entity (node), you could create duplicate data. 
You may also have problems loading the data and creating relationships between nodes.
You can add constraints to your database to stop the creation of nodes with duplicate IDs.
Create a unique constraint
The syntax for creating a unique constraint on a property is: syntax:
CREATE CONSTRAINT [constraint_name] [IF NOT EXISTS]
FOR (n:LabelName)
REQUIRE n.propertyName IS UNIQUE
e.g.
CREATE CONSTRAINT Person_tmdbId IF NOT EXISTS
FOR (x:Person) 
REQUIRE x.tmdbId IS UNIQUE
- The constraint is for a property on all nodes with a specified label.
- The constraint_name is optional, but it is good practice to specify one. If you do not specify a constraint name, Neo4j will create one for you.
- The IF NOT EXISTS clause is also optional - if not used Neo4j will generate an error if the constraint already exists.

You can check that the constraint has been created by running the following Cypher statement:
SHOW CONSTRAINTS

If you try to create a Person node with a duplicate tmdbId property value, Neo4j will raise an error.
CREATE (p:Person {tmdbId: 3}) RETURN p
ERROR: Node(25) already exists with label `Person` and property `tmdbId` = 3

Drop a constraint
If you need to drop a constraint, use the following Cypher statement.
DROP CONSTRAINT [constraint_name]
----------------------- now for the Movie label
// Create the Movie node constraint
CREATE CONSTRAINT Movie_movieId
FOR (x:Movie) 
REQUIRE x.movieId IS UNIQUE;

// Load the Movie nodes
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/movies.csv' AS row
MERGE (m:Movie {movieId: toInteger(row.movieId)})
SET
m.tmdbId = toInteger(row.movie_tmdbId),
m.imdbId = toInteger(row.movie_imdbId),
m.released = row.released,
m.title = row.title,
m.year = row.year,
m.plot = row.plot,
m.budget = row.budget;
-------------------------------------------next lesson:
In this lesson, you will:
Learn how to create relationships based on data in a CSV file
Create ACTED_IN relationships between the Person and Movie nodes.

ACTED_IN relationship
Run the Cypher statement to create the ACTED_IN relationships.
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/acted_in.csv' AS row
MATCH (p:Person {tmdbId: toInteger(row.person_tmdbId)})
MATCH (m:Movie {movieId: toInteger(row.movieId)})
MERGE (p)-[r:ACTED_IN]->(m)
SET r.role = row.role

To verify that you created the ACTED_IN relationships successfully, run the following Cypher statement to find people who acted in movies:
MATCH (p:Person)-[r:ACTED_IN]->(m:Movie) RETURN p, r, m LIMIT 25
------------------------------special query:
Directed and acted in
Once you have created the ACTED_IN and DIRECTED relationships, you can use the data to find people who directed and acted in the same movie.
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(p:Person)
RETURN p, m

-------------------------- Quiz
Check your understanding
airports.csv
airport_code|name|city|country
SFO|San Francisco International Airport|San Francisco|United States
NYC|John F. Kennedy International Airport|New York City|United States
LHR|London Heathrow Airport|London|United Kingdom

flights.csv
flight_number,airline,departure_airport,arrival_airport
SF_4863,Swift Flights,SFO,NYC
SF_4864,Swift Flights,NYC,SFO
AA_9135,America Airways,SFO,LHR
AA_9136,America Airways,LHR,SFO
BA_2945,Britain Atlantic,LHR,NYC
BA_2946,Britain Atlantic,NYC,LHR

...
LOAD CSV WITH HEADERS FROM 'file:///airports.csv' AS row FIELDTERMINATOR '|'

LOAD CSV WITH HEADERS 'file:///flights.csv' AS row
MATCH (d:Airport {airport_code: row.departure_airport})
MATCH (a:Airport {airport_code: row.arrival_airport})
MERGE (d)-[f:FLIGHT {flight_number: row.flight_number}]->(a)
SET f.airline = row.airline
===============================================================================
Data Types, Lists, and Labels
Data Types
Use this code to see all the data types of properties:
CALL apoc.meta.nodeTypeProperties()
YIELD nodeType, propertyName, propertyTypes
*similarly to RDBMS: table name, field names, data types

This is the code to change the data type from string to Date for [born] and [died] properties.
LOAD CSV WITH HEADERS FROM 'https://data.neo4j.com/importing-cypher/persons.csv' AS row
MERGE (p:Person {tmdbId: toInteger(row.person_tmdbId)})
SET
p.imdbId = toInteger(row.person_imdbId),
p.bornIn = row.bornIn,
p.name = row.name,
p.bio = row.bio,
p.poster = row.poster,
p.url = row.url,
p.born = date(row.born),
p.died = date(row.died)

*Using MERGE not CREATE?
As MERGE was used in this Cypher statement, you can run it multiple times without creating duplicate nodes. 
It will update the existing nodes with the new date values. If you used CREATE instead, 
you would create new nodes each time you ran the statement.

Advantages of using Date
The Date data type allows you to extract the year, month, and day from the date. For example,
MATCH (p:Person)
RETURN p.born.year as YearOfBirth

------------ for the movie label
Update and run the existing import to cast the year and budget properties to integers using the toInteger() function.

LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/movies.csv' AS row
MERGE (m:Movie {movieId: toInteger(row.movieId)})
SET
m.tmdbId = toInteger(row.movie_tmdbId),
m.imdbId = toInteger(row.movie_imdbId),
m.released = date(row.released),
m.title = row.title,
m.year = toInteger(row.year),
m.plot = row.plot,
m.budget = toInteger(row.budget),
m.imdbRating = toFloat(row.imdbRating),
m.poster = row.poster,
m.runtime = toInteger(row.runtime),
m.imdbVotes = toInteger(row.imdbVotes),
m.revenue = toInteger(row.revenue),
m.url = row.url
-------------------------------- Lesson
Lists
In this lesson, you will learn about:
- Multi-value properties and lists
- How to transform a string value into a list
- The split function

What is a Multi-value property?
A multi-value property is a property that can hold one or more values. Neo4j represents this type of data as a list (or "StringArray").
All values in a list must have the same data type. For example:
["Apple", "Banana, "Orange"]
[100, 55, 4]
The movies.csv data file contains multi-value properties, including:
- countries - the countries which produced the movie
- languages - the languages spoken in the movie

LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/movies.csv' AS row
MERGE (m:Movie {movieId: toInteger(row.movieId)})
SET
m.tmdbId = toInteger(row.movie_tmdbId),
m.imdbId = toInteger(row.movie_imdbId),
m.released = date(row.released),
m.title = row.title,
m.year = toInteger(row.year),
m.plot = row.plot,
m.budget = toInteger(row.budget),
m.imdbRating = toFloat(row.imdbRating),
m.poster = row.poster,
m.runtime = toInteger(row.runtime),
m.imdbVotes = toInteger(row.imdbVotes),
m.revenue = toInteger(row.revenue),
m.url = row.url,
m.countries = split(row.countries, '|'),
m.languages = split(row.languages, '|')


You can query data in a list using the IN operator. For example, finding all the movies where "French" is a listed language.
MATCH (m:Movie)
WHERE "France" IN m.countries
RETURN m

--------------------------------
Labels
In this lesson, you will learn how to add additional labels to existing nodes.
Add Actor label
Run the query to add the Actor label:
MATCH (p:Person)-[:ACTED_IN]->()
WITH DISTINCT p SET p:Actor

To cofirm:
MATCH (a:Actor) RETURN a LIMIT 25

Filtering by labels is faster
By adding the Actor label to the graph, queries that use the label rather than the relationship will be quicker to return.

For the Director:
MATCH (p:Person)-[:DIRECTED]->()
WITH DISTINCT p SET p:Director;

----------------------- new lesson:
Importing data considerations
In this module, you will learn about:
- The considerations you need to make when importing data into Neo4j
- Strategies for importing data into Neo4j, including making multiple passes over the data
- Why and how to split an import into transactions
- The next steps you can take to continue your learning

Building an Import Process
Resetting the data

Before you can re-run the import process, you must delete any existing data and drop any constraints.
The nodes and relationships within the graph hold all of the data. You will need to delete the relationships before deleting the nodes.
The following Cypher will delete the ACTED_IN and DIRECTED relationships:
MATCH (Person)-[r:ACTED_IN]->(Movie) DELETE r;
MATCH (Person)-[r:DIRECTED]->(Movie) DELETE r;

Once the relationships are deleted, you can delete the Person and Movie nodes:
MATCH (p:Person) DELETE p;
MATCH (m:Movie) DELETE m;

Alternatively, you can use DETACH DELETE to delete the nodes and relationships at the same time:
MATCH (p:Person) DETACH DELETE p;
MATCH (m:Movie) DETACH DELETE m;

You could also drop the constraints on the Person and Movie nodes if they exist:
DROP CONSTRAINT Person_tmdbId IF EXISTS;
DROP CONSTRAINT Movie_movieId IF EXISTS;

--------------------------------- Importing the data
Combining the queries above with those from the previous lessons will create a single import process.
// ---start---
// Delete nodes and relationships
MATCH (p:Person) DETACH DELETE p;
MATCH (m:Movie) DETACH DELETE m;

// Delete constraints if exists
DROP CONSTRAINT Person_tmdbId IF EXISTS;
DROP CONSTRAINT Movie_movieId IF EXISTS;

// Create Person and Movie constraints
CREATE CONSTRAINT Person_tmdbId IF NOT EXISTS
FOR (x:Person)
REQUIRE x.tmdbId IS UNIQUE;

CREATE CONSTRAINT Movie_movieId IF NOT EXISTS
FOR (x:Movie)
REQUIRE x.movieId IS UNIQUE;

// Import data from persons.csv and create Person nodes
:auto LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/persons.csv' AS row
CALL (row) {
    MERGE (p:Person {tmdbId: toInteger(row.person_tmdbId)})
    SET
    p.imdbId = toInteger(row.person_imdbId),
    p.bornIn = row.bornIn,
    p.name = row.name,
    p.bio = row.bio,
    p.poster = row.poster,
    p.url = row.url,
    p.born = date(row.born),
    p.died = date(row.died)
} IN TRANSACTIONS OF 10 ROWS;

// Import data from movies.csv and create Movie nodes
:auto LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/movies.csv' AS row
CALL (row) {
    MERGE (m:Movie {movieId: toInteger(row.movieId)})
    SET
    m.tmdbId = toInteger(row.movie_tmdbId),
    m.imdbId = toInteger(row.movie_imdbId),
    m.released = date(row.released),
    m.title = row.title,
    m.year = toInteger(row.year),
    m.plot = row.plot,
    m.budget = toInteger(row.budget),
    m.imdbRating = toFloat(row.imdbRating),
    m.poster = row.poster,
    m.runtime = toInteger(row.runtime),
    m.imdbVotes = toInteger(row.imdbVotes),
    m.revenue = toInteger(row.revenue),
    m.url = row.url,
    m.countries = split(row.countries, '|'),
    m.languages = split(row.languages, '|')
} IN TRANSACTIONS OF 10 ROWS;

// Create ACTED_IN and DIRECTED relationships between Person and Movie nodes
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/acted_in.csv' AS row
MATCH (p:Person {tmdbId: toInteger(row.person_tmdbId)})
MATCH (m:Movie {movieId: toInteger(row.movieId)})
MERGE (p)-[r:ACTED_IN]->(m)
SET r.role = row.role;

LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/directed.csv' AS row
MATCH (p:Person {tmdbId: toInteger(row.person_tmdbId)})
MATCH (m:Movie {movieId: toInteger(row.movieId)})
MERGE (p)-[r:DIRECTED]->(m);

// Create additional ACTOR and DIRECTOR labels on Person nodes
MATCH (p:Person)-[:ACTED_IN]->()
WITH DISTINCT p SET p:Actor;

MATCH (p:Person)-[:DIRECTED]->()
WITH DISTINCT p SET p:Director;

// ---end of script---

*Comments may be added to queries. Single line or inline comments begin with //, and multi-line comments are delimited by /* and */.

----------------------- Lesson
Transactions
The Cypher queries you have written will run within a single transaction. As a result, the data is rolled back if a failure occurs; and the graph is unchanged.
Importing significant volumes of data in a single transaction can result in large write operations - this can cause performance issues and potential failure.
You can split a query into multiple transactions using the CALL clause with IN TRANSACTIONS.
CALL {
  // query
} IN TRANSACTIONS [OF X ROWS]

--------------------------Lesson
Multiple passes
In this lesson, you will explore a single file that stores multiple nodes and relationships and the challenges of importing it into the graph.
Here is the book data you reviewed in a previous lesson:
id,title,author,publication_year,genre,rating,still_in_print,last_purchased
19515,The Heights,Anne Conrad,2012,Comedy,5,true,2023/4/12 8:17:00
39913,Starship Ghost,Michael Tyler,1985,Science Fiction|Horror,4.2,false,2022/01/16 17:15:56
60980,The Death Proxy,Tim Brown,2002,Horror,2.1,true,2023/11/26 8:34:26
18793,Chocolate Timeline,Mary R. Robb,1924,Romance,3.5,false,2022/9/17 14:23:45
67162,Stories of Three,Eleanor Link,2022,Romance|Comedy,2,true,2023/03/12 16:01:23
25987,Route Down Below,Tim Brown,2006,Horror,4.1,true,2023/09/24 15:34:18
image model: https://graphacademy.neo4j.com/courses/importing-cypher/4-import-considerations/3-multiple-passes/images/book-model.svg
Author -> wrote -> Book
The data is relatively simple, and a single Cypher query could import it into the graph:
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/books.csv'
AS row
MERGE (b:Book {id: row.id})
SET b.title = row.title
MERGE (a:Author {name: row.author})
MERGE (a)-[:WROTE]->(b)

Review the query and identify where it creates the Book and Author nodes and WROTE relationship.
However, if this was a more complicated data set with significantly more rows, you may experience issues with the import as it creates related data in a single pass.
Queries with multiple operations chained together have the potential to write data and then read data that is out of sync - which can result in an Eager operator.
The Eager operator will cause any operations to execute in their entirety before continuing, ensuring isolation between the different parts of the query. When importing data the Eager operator can cause high memory usage and performance issues.
A mechanism for avoiding the Eager operator is to break the import into smaller parts. By taking multiple passes over the data file, the query also becomes simpler to understand and change to fit the data model.
In this example, the import could be broken into three parts:
1. Create Book nodes
2. Create Author nodes
3. Create WROTE relationships

// Create `Book` nodes
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/books.csv'
AS row
MERGE (b:Book {id: row.id})
SET b.title = row.title;

// Create `Author` nodes
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/books.csv'
AS row
MERGE (a:Author {name: row.author});

// Create `WROTE` relationships
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing-cypher/books.csv'
AS row
MATCH (a:Author{name: row.author})
MATCH (b:Book{id: row.id})
MERGE (a)-[:WROTE]->(b);

------------------------------------- Lesson
Other Import Options
LOAD CSV is a convenient tool for importing data into Neo4j; there are however some considerations:
- You may need to write Cypher statements to transform the data into the desired format. Depending on the data complexity, this can be time-consuming.
- LOAD CSV may not be suitable for large data sets. The definition of large data sets depends on multiple factors, including the data structure, the use case, and the environment. A guideline of over 10 million rows is a good indicator for considering other import options.
- You may need to import data from multiple sources, and LOAD CSV may not be the best option for all of them.
- Complex business rules may require integration to other systems or data sources.
There are a multitude of options for importing data into Neo4j. The following sections provide an overview of some of the possibilities.
- Neo4j Data Importer
- neo4j-admin
- ETL (Extract, Transform, Load) Tool
- Custom integration using Neo4j drivers
=============================================================================== Installing Composer: https://getcomposer.org/download/
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
php -r "if (hash_file('sha384', 'composer-setup.php') === 'dac665fdc30fdd8ec78b38b9800061b4150413ff2e3b6f88543c636f7cd84f6db9189d43a81e5503cda447da73c7e5b6') { echo 'Installer verified'.PHP_EOL; } else { echo 'Installer corrupt'.PHP_EOL; unlink('composer-setup.php'); exit(1); }"
php composer-setup.php
php -r "unlink('composer-setup.php');"
next:
mv composer.phar /usr/local/bin/composer
to run:
php /usr/local/bin/composer/composer.phar
to install:
eliagbayani@ELIs-Mac-Studio php_neo4j %  php composer-setup.php --install-dir=/usr/local/bin/ --filename=composer
All settings correct for using Composer
Downloading...

Composer (version 2.2.25) successfully installed to: /usr/local/bin/composer/composer
Use it: php /usr/local/bin/composer/composer


composer init --require=neo4j/neo4j "dev-master"

php /usr/local/bin/composer/composer init --require=neo4j/neo4j "dev-master"
php /usr/local/bin/composer/composer init --require="neo4j/neo4j:dev-master"
----------------------- in Docker using PHP 8.2
php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
php -r "if (hash_file('sha384', 'composer-setup.php') === 'dac665fdc30fdd8ec78b38b9800061b4150413ff2e3b6f88543c636f7cd84f6db9189d43a81e5503cda447da73c7e5b6') { echo 'Installer verified'.PHP_EOL; } else { echo 'Installer corrupt'.PHP_EOL; unlink('composer-setup.php'); exit(1); }"
php composer-setup.php
php -r "unlink('composer-setup.php');"

All settings correct for using Composer
Downloading...
Composer (version 2.8.9) successfully installed to: /var/www/html/php_neo4j/composer.phar
Use it: php composer.phar

composer init --require=neo4j/neo4j "dev-master"

php composer.phar init --require=neo4j/neo4j "dev-master"

php composer.phar require neo4j/neo4j

-------------------------- using laudis

composer require laudis/neo4j-php-client



--------------------------- using neo4j-php-client
works OK! https://github.com/neo4j-php/neo4j-php-client

    composer      require laudis/neo4j-php-client
-> from orig doc: https://medium.com/@.Chromax/here-is-a-step-by-step-walkthrough-to-use-neo4j-with-php-b4a699f80e9b
php composer.phar require laudis/neo4j-php-client
-> worked OK


===============================================================================

docker exec -it a18 cypher-shell -u neo4j -p eli_neo4j -d system "SHOW DATABASES;"
docker exec -it a18 cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE elidb;"
docker exec -it a18 cypher-shell -u neo4j -p eli_neo4j -d system "MATCH (n) RETURN n;"
docker exec -it a18 cypher-shell -u neo4j -p eli_neo4j -d system "CREATE DATABASE elidb;"
docker exec -it a18 cypher-shell -u neo4j -p eli_neo4j -d system "CREATE DATABASE WoRMSdb;"

Official docs for neo4j-admin import: https://neo4j.com/docs/operations-manual/current/tutorial/neo4j-admin-import/


cypher-shell -u neo4j -p eli_neo4j -d system "DROP DATABASE elidb;"
cypher-shell -u neo4j -p eli_neo4j -d system "CREATE DATABASE elidb;"
cypher-shell -u neo4j -p eli_neo4j -d system "SHOW DATABASES;"

=========================================================================== actors movies roles
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE elidb;"
neo4j-admin database import full elidb --overwrite-destination \
--nodes=import/movies.csv \
--nodes=import/actors.csv \
--relationships=import/roles.csv --verbose --array-delimiter="U+007C"
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE elidb;"
===========================================================================
cypher-shell -u neo4j -p eli_neo4j -d system "CREATE DATABASE elidb;"
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE elidb;"
e.g. MATCH (p:Actor {name: "Keanu Reeves"})-[r:ACTED_IN]->(m:Movie) RETURN p, r, m

Another example of data import: https://medium.com/@matthewghannoum/import-your-csv-data-into-a-neo4j-graph-database-d019b95115b1
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE elidb;"
neo4j-admin database import full elidb --overwrite-destination \
--nodes=import/dataset/nodes/people.csv \
--nodes=import/dataset/nodes/posters.csv \
--relationships=import/dataset/edges/follows.csv \
--relationships=import/dataset/edges/subscribes.csv 
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE elidb;"

e.g. MATCH p = ()-[r:follows]->() RETURN p limit 25
e.g. MATCH p = ()-[r:subscribes_to]->() RETURN p limit 25
------------------------------------------------------------------------------
cypher-shell -u neo4j -p eli_neo4j -d system "DROP DATABASE elidb;"
cypher-shell -u neo4j -p eli_neo4j -d system "CREATE DATABASE elidb;"
cypher-shell -u neo4j -p eli_neo4j -d system "CREATE DATABASE testdb;"
cypher-shell -u neo4j -p eli_neo4j -d system "SHOW DATABASES;"
=========================================================================== testing EOL trait schema
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE testdb;"
neo4j-admin database import full testdb --overwrite-destination \
--nodes=import/dataset_test/nodes/Resource.csv \
--nodes=import/dataset_test/nodes/Page.csv \
--relationships=import/dataset_test/edges/Parent.csv 
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE testdb;"

WoRMS main (no parentNameUsageID)
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE testdb;"
neo4j-admin database import full testdb --overwrite-destination \
--nodes=import/dataset_test/nodes/Resource.csv \
--nodes=import/dataset_test/nodes/Page.csv \
--nodes=import/dataset_test/nodes/Vernacular.csv \
--nodes=import/dataset_test/nodes/Term.csv \
--nodes=import/dataset_test/nodes/Trait.csv \
--relationships=import/dataset_test/edges/Parent.csv \
--relationships=import/dataset_test/edges/Vernacular.csv \
--relationships=import/dataset_test/edges/Trait.csv \
--relationships=import/dataset_test/edges/Inferred_Trait.csv \
--relationships=import/dataset_test/edges/Predicate.csv \
--relationships=import/dataset_test/edges/Object_Term.csv \
--relationships=import/dataset_test/edges/Normal_Units_Term.csv \
--relationships=import/dataset_test/edges/Supplier.csv 
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE testdb;"

MATCH (t:Trait)<-[:TRAIT]-(p:Page),
(t)-[:SUPPLIER]->(r:Resource),
(t)-[:PREDICATE]->(pred:Term)
WHERE p.page_id = 328651 AND pred.uri = "http://purl.obolibrary.org/obo/VT_0001259"
OPTIONAL MATCH (t)-[:units_term]->(units:Term)
RETURN p.canonical, pred.name, t.measurement, units.name, r.resource_id, p.page_id, t.eol_pk, t.source
LIMIT 1

MATCH (t:Trait)<-[:TRAIT]-(p:Page),
      (t)-[:SUPPLIER]->(r:Resource),
      (t)-[:PREDICATE]->(pred:Term)
OPTIONAL MATCH (t)-[:OBJECT_TERM]->(obj:Term)
OPTIONAL MATCH (t)-[:NORMAL_UNITS_TERM]->(units:Term)
RETURN r.resource_id, t.eol_pk, t.resource_ok, t.source, p.page_id, t.scientific_name, pred.uri, pred.name,
       t.object_page_id, obj.uri, obj.name, t.normal_measurement, units.uri, units.name, t.normal_units, t.literal
LIMIT 5

MATCH (origin:Page {canonical: "Gadus morhua"})-[:PARENT*]->(ancestor:Page)
OPTIONAL MATCH (ancestor)-[:PARENT]->(parent_of_ancestor:Page)
RETURN ancestor.page_id, ancestor.canonical, parent_of_ancestor.page_id 
LIMIT 100

MATCH (origin:Page {canonical: "Gadus morhua"})-[:PARENT]->(parent:Page)
RETURN origin.page_id AS page_id,
       origin.canonical AS canonical,
       parent.page_id AS parent_id
UNION ALL MATCH (origin:Page {canonical: "Gadus morhua"})-[:PARENT*]->(ancestor:Page)
OPTIONAL MATCH (ancestor)-[:PARENT]->(parent:Page)
RETURN ancestor.page_id AS page_id, 
       ancestor.canonical AS canonical,
       parent.page_id AS parent_id
LIMIT 100

MATCH (descendant:Page)-[:PARENT*]->(ancestor:Page {page_id: "1905"})
RETURN COUNT(descendant)
LIMIT 1

MATCH e = (p:Page {canonical: "Lagocephalus sceleratus"})-[r:TRAIT]->() RETURN e
MATCH e = (p:Page {canonical: "Lagocephalus sceleratus"})-[r:TRAIT]->(t:Trait {literal: "http://marineregions.org/mrgid/4280"}) RETURN e
MATCH e = (p:Page {canonical: "Aster"})-[r:TRAIT]->(t:Trait {predicate: "http://eol.org/schema/terms/NativeRange"}) RETURN e

GloBI main
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE testdb;"
neo4j-admin database import full testdb --overwrite-destination \
--nodes=import/dataset_test/nodes/Resource.csv \
--nodes=import/dataset_test/nodes/Page.csv \
--nodes=import/dataset_test/nodes/Term.csv \
--nodes=import/dataset_test/nodes/Trait.csv \
--relationships=import/dataset_test/edges/Parent.csv \
--relationships=import/dataset_test/edges/Trait.csv \
--relationships=import/dataset_test/edges/Inferred_Trait.csv \
--relationships=import/dataset_test/edges/Predicate.csv 
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE testdb;"


MATCH e = (p:Page {canonical: "Gadus morhua"})-[r:PARENT]->() RETURN e
MATCH e = (p:Page {canonical: "Lagocephalus sceleratus"})-[r:TRAIT]->() RETURN e
MATCH x = (c:Page {canonical: 'Ocypode'})<-[:PARENT]-(p:Page) RETURN x
MATCH X = (startNode:Page {canonical: 'Ocypode quadrata'})-[:PARENT*]->(descendant) RETURN X
MATCH e = (t:Page {canonical: "Gadus morhua"})-[r:VERNACULAR]->() RETURN e

=========================================================================== dump database
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE elidb;"
neo4j-admin database dump --to-path=import/dumps/ elidb
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE elidb;"
===========================================================================

=========================================================================== Globi -> database import
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE Globidb;"
neo4j-admin database import full Globidb --overwrite-destination \
--nodes=import/GloBI/taxa.csv \
--relationships=import/GloBI/predicates.csv \
--verbose \
--array-delimiter="U+007C" \
--schema=import/GloBI/schema.cypher
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE Globidb;"
=========================================================================== WoRMS -> database import
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE WoRMSdb;"
neo4j-admin database import full WoRMSdb --overwrite-destination \
--nodes=import/WoRMS/taxa.csv \
--nodes=import/WoRMS/measurements.csv \
--relationships=import/WoRMS/predicates_measurements.csv \
--verbose \
--array-delimiter="U+007C" \
--schema=import/WoRMS/schema.cypher
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE WoRMSdb;"

===============--- incremental

cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE elidb;"
neo4j-admin database import full elidb --overwrite-destination \
--nodes=import/WoRMS/taxa.csv \
--nodes=import/WoRMS/measurements.csv \
--relationships=import/WoRMS/predicates_measurements.csv \
--verbose \
--array-delimiter="U+007C" \
--schema=import/WoRMS/schema.cypher
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE elidb;"


cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE elidb;"
neo4j-admin database import incremental elidb  \
--force \
--nodes=import/WoRMS/taxa_2.csv \
--nodes=import/WoRMS/measurements_2.csv \
--relationships=import/WoRMS/predicates_measurements_2.csv \
--verbose \
--array-delimiter="U+007C" 
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE elidb;"


MATCH e = (t:Taxon {vernacularName: "Chameleon Goby"})-[]->() RETURN e

cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE elidb;"
neo4j-admin database import full elidb --overwrite-destination \
--nodes=import/WoRMS/taxa_2.csv \
--nodes=import/WoRMS/measurements_2.csv \
--verbose \
--array-delimiter="U+007C" \
--schema=import/WoRMS/schema.cypher
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE elidb;"



=========================================================================== load from file.cypher | cypher file | loading cypher | load from cypher
cat export.cypher | cypher-shell -u neo4j -p eli_neo4j
=========================================================================== database dump OK
cypher-shell -u neo4j -p eli_neo4j -d system "STOP DATABASE elidb;"
neo4j-admin database dump --to-path=import/dumps/ elidb
cypher-shell -u neo4j -p eli_neo4j -d system "START DATABASE elidb;"
===========================================================================
CALL db.schema.visualization()
MATCH ()-[r]->() RETURN r
MATCH ()-[r]->() RETURN DISTINCT r
MATCH e = (p:Taxon {taxonID: "484360"})-[r:ARE_SYMBIONTS_OF]->() RETURN e
MATCH p = ()-[r:EAT]->() RETURN p limit 10
MATCH e = (t:Taxon {scientificName: "Egira curialis"})-[r:EAT]->() RETURN e
MATCH e = (t:Taxon {scientificName: "Myotis davidii"}) RETURN e limit 20
=========================================================================== neo4j-admin database import full
from: https://neo4j.com/docs/operations-manual/current/tutorial/neo4j-admin-import/
Handy tips:
The details of a CSV file header format can be found at CSV header format.
  hyperlink: CSV header format
  https://neo4j.com/docs/operations-manual/current/import/#import-tool-header-format
To show available databases, use the Cypher query SHOW DATABASES.
To remove a database, use the Cypher query DROP DATABASE database_name.
To create a database, use the Cypher query CREATE DATABASE database_name.

bin/neo4j-admin database import full neo4j 
  --nodes=import/movies.csv 
  --nodes=import/actors.csv 
  --relationships=import/roles.csv

=========================================================================== another example
The data
The following CSV files have:
--delimiter=";"
--array-delimiter="U+007C" (U+007C is the Unicode code point for the character |)
--quote="'"

movies2.csv
movieId:ID;title;year:int;:LABEL
tt0133093;'The Matrix';1999;Movie
tt0234215;'The Matrix Reloaded';2003;Movie|Sequel
tt0242653;'The Matrix Revolutions';2003;Movie|Sequel

actors2.csv
personId:ID;name;:LABEL
keanu;'Keanu Reeves';Actor
laurence;'Laurence Fishburne';Actor
carrieanne;'Carrie-Anne Moss';Actor

roles2.csv
:START_ID;role;:END_ID;:TYPE
keanu;'Neo';tt0133093;ACTED_IN
keanu;'Neo';tt0234215;ACTED_IN
keanu;'Neo';tt0242653;ACTED_IN
laurence;'Morpheus';tt0133093;ACTED_IN
laurence;'Morpheus';tt0234215;ACTED_IN
laurence;'Morpheus';tt0242653;ACTED_IN
carrieanne;'Trinity';tt0133093;ACTED_IN
carrieanne;'Trinity';tt0234215;ACTED_IN
carrieanne;'Trinity';tt0242653;ACTED_IN

bin/neo4j-admin database import full neo4j 
  --delimiter=";" 
  --array-delimiter="U+007C" 
  --quote="'" 
  --nodes=import/movies2.csv 
  --nodes=import/actors2.csv 
  --relationships=import/roles2.csv

=========================================================================== Provide indexes and constraints during import
You can use the --schema option to create and populate indexes/constraints during the import process. It works for the block format and both full and incremental import. For incremental import, this functionality is available from 2025.02.
You should have a Cypher script containing only CREATE INDEX|CONSTRAINT commands to be parsed and executed. This file uses ';' as the separator.
For example:
CREATE INDEX PersonNameIndex FOR (i:Person) ON (i.name);
CREATE CONSTRAINT PersonAgeConstraint FOR (c:Person) REQUIRE c.age IS :: INTEGER

List of supported indexes and constraints that can be created by the import tool:
RANGE
LOOKUP
POINT
TEXT
FULL-TEXT
VECTOR

For example:
Create indexes and constraints during full import
  bin/neo4j-admin database import full neo4j 
    --nodes=import/movies.csv 
    --nodes=import/actors.csv 
    --relationships=import/roles.csv 
    --schema=import/schema.cypher
Create indexes and constraints during incremental import
  bin/neo4j-admin database import incremental 
    --stage=all 
    --nodes=import/movies.csv 
    --nodes=import/actors.csv 
    --relationships=import/roles.csv 
    --schema=import/schema.cypher
=========================================================================== separate header file
bin/neo4j-admin database import full neo4j 
  --nodes=import/movies3-header.csv,import/movies3.csv 
  --nodes=import/actors3-header.csv,import/actors3.csv 
  --relationships=import/roles3-header.csv,import/roles3.csv
===========================================================================
The import tool can also process single-file compressed archives, for example:
--nodes=import/nodes.csv.gz
--relationships=import/relationships.zip
=========================================================================== Multiple input files
bin/neo4j-admin database import full neo4j 
  --nodes=import/movies4-header.csv,import/movies4-part1.csv,import/movies4-part2.csv 
  --nodes=import/actors4-header.csv,import/actors4-part1.csv,import/actors4-part2.csv 
  --relationships=import/roles4-header.csv,import/roles4-part1.csv,import/roles4-part2.csv
=========================================================================== Regular expression
For example, letâ€™s assume that you have the following files:
movies4-header.csv
movies4-data1.csv
movies4-data2.csv
movies4-data12.csv
For example: --nodes "import/movies4-header.csv,movies-data.*"

bin/neo4j-admin database import full neo4j 
  --nodes="import/movies4-header.csv,import/movies4-part.*" 
  --nodes="import/actors4-header.csv,import/actors4-part.*" 
  --relationships="import/roles4-header.csv,import/roles4-part.*"
=========================================================================== the data: adding labels
bin/neo4j-admin database import full neo4j 
  --nodes=Movie=import/movies5a.csv               -> just a Movie label
  --nodes=Movie:Sequel=import/sequels5a.csv       -> 2 labels: Movie and Sequel
  --nodes=Actor=import/actors5a.csv 
  --relationships=import/roles5a.csv
=========================================================================== Using the same relationship type for every relationship
e.g. relationship ACTED_IN
bin/neo4j-admin database import full neo4j 
  --nodes=import/movies5b.csv 
  --nodes=import/actors5b.csv 
  --relationships=ACTED_IN=import/roles5b.csv
=========================================================================== Properties

Nodes and relationships can have properties. The property type is specified in the CSV header row, see CSV header format.
  hyperlink = CSV header format
  https://neo4j.com/docs/operations-manual/current/import/#import-tool-header-format

=========================================================================== ID space 
To define an ID space Movie-ID for movieId:ID, use the syntax movieId:ID(Movie-ID).
movies7.csv
movieId:ID(Movie-ID),title,year:int,:LABEL
1,"The Matrix",1999,Movie
2,"The Matrix Reloaded",2003,Movie;Sequel
3,"The Matrix Revolutions",2003,Movie;Sequel

actors7.csv
personId:ID(Actor-ID),name,:LABEL
1,"Keanu Reeves",Actor
2,"Laurence Fishburne",Actor
3,"Carrie-Anne Moss",Actor

You also need to reference the appropriate ID space in your relationships file so it knows which nodes to connect.

roles7.csv
:START_ID(Actor-ID),role,:END_ID(Movie-ID)
1,"Neo",1
1,"Neo",2
1,"Neo",3
2,"Morpheus",1
2,"Morpheus",2
2,"Morpheus",3
3,"Trinity",1
3,"Trinity",2
3,"Trinity",3

bin/neo4j-admin database import full neo4j 
  --nodes=import/movies7.csv 
  --nodes=import/actors7.csv 
  --relationships=ACTED_IN=import/roles7.csv
=========================================================================== Skip relationships referring to missing nodes
If there is a bad relationship in the input data, this import process will fail.

bin/neo4j-admin database import full neo4j 
  --nodes=import/movies8a.csv 
  --nodes=import/actors8a.csv 
  --relationships=import/roles8a.csv

This will not fail:
bin/neo4j-admin database import full neo4j 
  --skip-bad-relationships 
  --nodes=import/movies8a.csv 
  --nodes=import/actors8a.csv 
  --relationships=import/roles8a.csv

The data files are successfully imported and the bad relationship is ignored. An entry is written to the import.report file.
e.g. import.report file
ignore bad relationships
InputRelationship:
   source: roles8a.csv:11
   properties: [role, Emil]
   startNode: emil (global id space)
   endNode: tt0133093 (global id space)
   type: ACTED_IN
 referring to missing node emil
=========================================================================== Skip nodes with the same ID
bin/neo4j-admin database import full neo4j --skip-duplicate-nodes --nodes=import/actors8b.csv
The data files are successfully imported and the bad node is ignored. An entry is written to the import.report file.
e.g. import.report file
ignore bad nodes
ID 'laurence' is defined more than once in global ID space, at least at actors8b.csv:3 and actors8b.csv:5
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================

sudo chown -R 7474:7474 /path/to/mounted/directory
sudo chmod -R u+rwX,g+rX,o-wrx /path/to/mounted/directory
chown -R 7474:7474 data/
chown -R 7474:7474 data/.
chown -R 7474:7474 import/
chown -R 7474:7474 import/.
chmod -R 777 data/
chmod -R 777 data/.
chmod -R 777 import/
chmod -R 777 import/.



